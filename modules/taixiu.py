from zlapi.models import Message
from PIL import Image
import os
import random
import time

users = {}
command_last_used = {}
command_usage_count = {}
# received_messages = []

des = {
    'version': "1.0.2",
    'credits': "dzi",
    'description': "txiu dangky/dangnhap"
}
def load_users():
    if os.path.exists('tt.txt'):
        try:
            with open('tt.txt', 'r') as f:
                for line in f:
                    parts = line.strip().split('|')
                    if len(parts) == 7:
                        user_id, username, password, balance, wins, losses, used_codes = parts
                        users[user_id] = {
                            "username": username,
                            "password": password,
                            "balance": int(balance),
                            "wins": int(wins),
                            "losses": int(losses),
                            "used_codes": set(used_codes.split(',')) if used_codes else set()
                        }
        except Exception as e:
            print(f"Error loading tt.txt: {e}")

def save_users():
    with open('tt.txt', 'w') as f:
        for user_id, user_info in users.items():
            used_codes = ','.join(user_info["used_codes"])
            f.write(f"{user_id}|{user_info['username']}|{user_info['password']}|{user_info['balance']}|{user_info['wins']}|{user_info['losses']}|{used_codes}\n")

def format_currency(amount):
    return '{:,.0f} VNƒê'.format(amount).replace(',', '.')

def get_user_name(user_id):
    if user_id in users:
        return users[user_id]["username"]
    else:
        return f"Ng∆∞·ªùi d√πng {user_id}"
    
def roll_dice():
    return [random.randint(1, 6) for _ in range(3)]

def determine_result(total):
    if total <= 10:
        return 'X·ªâu'
    elif total >= 11:
        return 'T√†i'

def check_cooldown(command, author_id, cooldown_period=10):
    current_time = time.time()
    if author_id in command_last_used and command in command_last_used[author_id]:
        last_used_time = command_last_used[author_id][command]
        if current_time - last_used_time < cooldown_period:
            return True, cooldown_period - (current_time - last_used_time)
    return False, 0

def update_command_usage(command, author_id):
    current_time = time.time()
    if author_id not in command_last_used:
        command_last_used[author_id] = {}
    command_last_used[author_id][command] = current_time
    
    if author_id not in command_usage_count:
        command_usage_count[author_id] = {}
    if command not in command_usage_count[author_id]:
        command_usage_count[author_id][command] = 0
    command_usage_count[author_id][command] += 1

# def send_dice_images(dice, thread_id, thread_type, client):
#     # L·∫•y ƒë∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c ch·ª©a file hi·ªán t·∫°i
#     current_dir = os.path.dirname(__file__)
#     image_paths = []
    
#     for die in dice:
#         # T·∫°o ƒë∆∞·ªùng d·∫´n t·ªõi ·∫£nh x√≠ ng·∫ßu
#         image_path = os.path.join(current_dir, 'dice_images', f'{die}.png')
        
#         if os.path.exists(image_path):
#             image_paths.append(image_path)
#         else:
#             print(f"Image not found: {image_path}")

#     if image_paths:
#         client.sendMultiLocalImage(
#             imagePathList=image_paths,
#             thread_id=thread_id,
#             thread_type=thread_type
#             # width=1200,
#             # height=1600
#         )
def create_dice_image(dice):
    # L·∫•y ƒë∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c ch·ª©a file hi·ªán t·∫°i
    current_dir = os.path.dirname(__file__)
    
    dice_images = []
    for die in dice:
        image_path = os.path.join(current_dir, 'dice_images', f'{die}.png')
        if os.path.exists(image_path):
            dice_images.append(Image.open(image_path))
        else:
            print(f"Image not found: {image_path}")
            return None
    
    if len(dice_images) == 3:
        # Gi·∫£ s·ª≠ c√°c ·∫£nh c√≥ k√≠ch th∆∞·ªõc gi·ªëng nhau
        width, height = 480, 480
        total_width = width * 3  # ·∫¢nh cu·ªëi s·∫Ω c√≥ chi·ªÅu r·ªông b·∫±ng ba l·∫ßn chi·ªÅu r·ªông m·ªôt ·∫£nh
        combined_image = Image.new('RGB', (total_width, height))
        
        # D√°n ba ·∫£nh x√≠ ng·∫ßu v√†o ·∫£nh m·ªõi
        for i, dice_img in enumerate(dice_images):
            combined_image.paste(dice_img, (i * width, 0))
        
        # L∆∞u ·∫£nh g·ªôp n√†y v√†o m·ªôt t·ªáp t·∫°m
        output_image_path = os.path.join(current_dir, 'combined_dice.png')
        combined_image.save(output_image_path)
        
        return output_image_path
    else:
        print("Kh√¥ng ƒë·ªß ·∫£nh x√≠ ng·∫ßu ƒë·ªÉ g·ªôp.")
        return None


def handle_taixiu_command(message, message_object, thread_id, thread_type, author_id, client):
    try:
        # group_name = fetchGroupName(thread_id)
        # if group_name != client.allowed_group_name:
        #     return
        load_users()
        user_name = get_user_name(author_id)
        if not isinstance(message, str):
            print(f"Lo·∫°i tin nh·∫Øn kh√¥ng mong ƒë·ª£i: {type(message)}")
            return
        query = message.strip().split()
        help_text = (
                f"üìú **Danh s√°ch l·ªánh:**\n"
                f"‚ûü `!txiu dangky (t√™n) (m·∫≠t kh·∫©u)`: ƒêƒÉng k√Ω ng∆∞·ªùi d√πng v√† nh·∫≠n 100.000 VNƒê üéâ\n"
                f"‚ûü `!txiu dangnhap (t√™n) (m·∫≠t kh·∫©u)`: ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng üîê\n"
                # f"‚ûü `-taixiu play (s·ªë ti·ªÅn) (T/X)`: Ch∆°i t√†i x·ªâu üé≤\n"
                f"‚ûü `!txiu (t/x/t√†i/x·ªâu) (s·ªë ti·ªÅn)`: Ch∆°i t√†i x·ªâu üé≤\n"
                f"‚ûü `!txiu sodu`: Ki·ªÉm tra s·ªë d∆∞ hi·ªán c√≥ üíµ\n"
                f"‚ûü `!txiu doipass (m·∫≠t kh·∫©u m·ªõi)`: Thay ƒë·ªïi m·∫≠t kh·∫©u c·ªßa b·∫°n üîë\n"               
                f"‚ûü `!txiu bxh`: Hi·ªÉn th·ªã b·∫£ng x·∫øp h·∫°ng 10 ng∆∞·ªùi gi√†u nh·∫•t üèÜ\n"
                f"‚ûü `!txiu ct (t√™n ng∆∞·ªùi nh·∫≠n) (s·ªë ti·ªÅn)`: Chuy·ªÉn ti·ªÅn cho ng∆∞·ªùi kh√°c üí∏\n"
                f"‚ûü `!txiu code (m√£)`: Nh·∫≠p m√£ ƒë·ªÉ nh·∫≠n ti·ªÅn th∆∞·ªüng üéÅ\n"
        )
        if len(query) < 2:
            client.sendMessage(Message(text=help_text), thread_id, thread_type)
            return
        command = query[1].lower()
        if command == 'dangky':
            if len(query) != 4:
                client.sendMessage(Message(text=f"{user_name} ‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng l·ªánh `-taixiu dangky (t√™n) (m·∫≠t kh·∫©u)`."), thread_id, thread_type)
                return
            username = query[2]
            password = query[3]
            if username and password:
                if author_id not in users:
                    users[author_id] = {"username": username, "balance": 100000, "password": password, "wins": 0, "losses": 0, "used_codes": set()}
                    formatted_balance = format_currency(users[author_id]["balance"])
                    client.sendMessage(Message(text=f"{user_name} üéâ ƒêƒÉng k√Ω th√†nh c√¥ng! {username} ƒë√£ nh·∫≠n {formatted_balance}."), thread_id, thread_type)
                    save_users()
                else:
                    client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è B·∫°n ƒë√£ ƒëƒÉng k√Ω r·ªìi."), thread_id, thread_type)
            else:
                client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è Vui l√≤ng cung c·∫•p t√™n v√† m·∫≠t kh·∫©u."), thread_id, thread_type)
        elif command == 'dangnhap':
            if len(query) != 4:
                client.sendMessage(Message(text=f"{user_name} ‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng l·ªánh `-taixiu dangnhap (t√™n) (m·∫≠t kh·∫©u)`."), thread_id, thread_type)
                return
            username = query[2]
            password = query[3]
            user_id = next((uid for uid, data in users.items() if data["username"] == username), None)
            if user_id and users[user_id]["password"] == password:
                client.sendMessage(Message(text=f"{user_name} üéâ ƒêƒÉng nh·∫≠p th√†nh c√¥ng! Ch√†o m·ª´ng tr·ªü l·∫°i, {username}."), thread_id, thread_type)
            else:
                client.sendMessage(Message(text=f"{user_name} ‚ùå T√™n ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng."), thread_id, thread_type)
            
        elif command == 'doipass':
            if len(query) != 3:
                client.sendMessage(Message(text=f"{user_name} ‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng l·ªánh `-taixiu doipass (m·∫≠t kh·∫©u m·ªõi)`."), thread_id, thread_type)
                return

            new_password = query[2]
            
            if author_id not in users:
                client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p ƒë·ªÉ thay ƒë·ªïi m·∫≠t kh·∫©u."), thread_id, thread_type)
                return

            # Update the password
            users[author_id]["password"] = new_password
            save_users()
            client.sendMessage(Message(text=f"{user_name} üîë B·∫°n ƒë√£ thay ƒë·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng."), thread_id, thread_type)

        elif command == 'sodu':
            if author_id not in users:
                client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p ƒë·ªÉ ki·ªÉm tra s·ªë d∆∞."), thread_id, thread_type)
                return

            formatted_balance = format_currency(users[author_id]["balance"])
            client.sendMessage(Message(text=f"{user_name} üí∞ S·ªë d∆∞ hi·ªán t·∫°i c·ªßa b·∫°n: {formatted_balance}."), thread_id, thread_type)

        # elif command == 'play':
        elif command in ['t', 'x', 't√†i', 'x·ªâu']:
            cooldown_period = 5  # ƒê·∫∑t th·ªùi gian ƒë·ª£i khi b·ªã cooldown
            cooldown_required, time_left = check_cooldown("-taixiu", author_id, cooldown_period)
            if cooldown_required:
                client.sendMessage(Message(text=f"{user_name} ‚è≥ B·∫°n ƒë√£ s·ª≠ d·ª•ng l·ªánh `-taixiu` qu√° 2 l·∫ßn. Vui l√≤ng ƒë·ª£i {int(time_left)} gi√¢y ƒë·ªÉ d√πng l·∫°i."), thread_id, thread_type)
                return
            # if len(query) != 4:
            if len(query) != 3:
                client.sendMessage(Message(text=f"{user_name} ‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng l·ªánh `-taixiu (t/x/t√†i/x·ªâu) (s·ªë ti·ªÅn)`."), thread_id, thread_type)
                return
            try:
                bet_amount = int(query[2])
                # bet_choice = query[3].upper()
                bet_choice = query[1].upper()
            except ValueError:
                client.sendMessage(Message(text=f"{user_name} ‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá."), thread_id, thread_type)
                return
            # if bet_choice not in ['T', 'X']:
            #     client.sendMessage(Message(text=f"{user_name} ‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng `T` cho T√†i, `X` cho X·ªâu, `H` cho Ho√†."), thread_id, thread_type)
            #     return
            if author_id not in users:
                client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p ƒë·ªÉ ch∆°i t√†i x·ªâu."), thread_id, thread_type)
                return
            if users[author_id]["balance"] < bet_amount:
                client.sendMessage(Message(text=f"{user_name} ‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ c∆∞·ª£c {format_currency(bet_amount)}."), thread_id, thread_type)
                return
            update_command_usage("-taixiu", author_id)
            dice = roll_dice()
            total = sum(dice)
            result = determine_result(total)
            formatted_dice = ' + '.join(map(str, dice))
            formatted_total = format_currency(total)

            current_dir = os.path.dirname(__file__)
            gif_path = os.path.join(current_dir, 'dice_images', f'xingau.gif')

            client.sendMessage(Message(text=f"ƒêang lƒÉc..."), thread_id, thread_type, ttl=5000)
            gif_response = client.sendLocalGif(
                gifPath=gif_path,
                thumbnailUrl="https://i.imgur.com/lV7QJp9.jpeg",
                thread_id=thread_id,
                thread_type=thread_type,
                width=800,
                height=466,
                ttl=5000
            )
            time.sleep(5)
            # ƒê·ª£i 3 gi√¢y
            # time.sleep(3)

            # L·∫•y msgId t·ª´ gif_response
            # gif_msg_id = gif_response.msgId

            # Gi·∫£ s·ª≠ messages l√† danh s√°ch c√°c message_object ƒë√£ l∆∞u
            # received_messages = []
            # messages = [
            #     # Th√™m c√°c message_object ƒë√£ l∆∞u ·ªü ƒë√¢y
            #     Message(msgId='5854648152499', cliMsgId='1726940888459', ...),
            #     Message(msgId='123456789', cliMsgId='987654321', ...),
            #     # ...
            # ]
            # received_messages.append(message_object)

            # # D√≤ t√¨m message_object v·ªõi msgId tr√πng kh·ªõp
            # matching_message = None
            # for message_object2 in received_messages:
            #     print(f"ABCD: {message_object2.msgId}")
            #     print(f"EAAA: {gif_msg_id}")
            #     if message_object2.msgId == gif_msg_id:
            #         matching_message = message_object2
            #         break

            # # Ki·ªÉm tra v√† thu h·ªìi
            # if matching_message:
            #     cli_msg_id = matching_message.cliMsgId

            #     # Thu h·ªìi GIF
            #     undo_response = client.undoMessage(
            #         msgId=gif_msg_id,
            #         cliMsgId=cli_msg_id,
            #         thread_id=thread_id,
            #         thread_type=thread_type
            #     )

            #     # Ki·ªÉm tra k·∫øt qu·∫£ thu h·ªìi
            #     if undo_response.get("error_code") != 0:
            #         print(f"Error while undoing GIF: {undo_response.get('error_message')}")
            # else:
            #     print("Kh√¥ng t√¨m th·∫•y message_object n√†o tr√πng kh·ªõp v·ªõi msgId c·ªßa GIF.")
            # D√≤ t√¨m message_object v·ªõi msgId tr√πng kh·ªõp
            # ƒê·ª£i 3 gi√¢y
            # time.sleep(10)

            # # L·∫•y msgId t·ª´ gif_response
            # gif_msg_id = gif_response.msgId

            # # D√≤ t√¨m message_object v·ªõi msgId tr√πng kh·ªõp
            # matching_message = next((msg for msg in received_messages if msg.msgId == gif_msg_id), None)

            # # Ki·ªÉm tra v√† thu h·ªìi
            # if matching_message:
            #     cli_msg_id = matching_message.cliMsgId

            #     # Thu h·ªìi GIF
            #     undo_response = client.undoMessage(
            #         msgId=gif_msg_id,
            #         cliMsgId=cli_msg_id,
            #         thread_id=thread_id,
            #         thread_type=thread_type
            #     )

            #     # Ki·ªÉm tra k·∫øt qu·∫£ thu h·ªìi
            #     if undo_response.get("error_code") != 0:
            #         print(f"Error while undoing GIF: {undo_response.get('error_message')}")
            # else:
            #     print("Kh√¥ng t√¨m th·∫•y message_object n√†o tr√πng kh·ªõp v·ªõi msgId c·ªßa GIF.")

            if bet_choice == 'T' and result == 'T√†i' or bet_choice == 'X' and result == 'X·ªâu' or bet_choice == 'H' and result == 'Ho√†':
                winnings = bet_amount * 2
                users[author_id]["balance"] += winnings
                users[author_id]["wins"] += 1
                formatted_winnings = format_currency(winnings)
                response=Message(text=f"{user_name} üéâ B·∫°n th·∫Øng! K·∫øt qu·∫£ x√∫c x·∫Øc: {formatted_dice} = {formatted_total}. K·∫øt qu·∫£: {result}. B·∫°n nh·∫≠n ƒë∆∞·ª£c {formatted_winnings}.")
            else:
                users[author_id]["balance"] -= bet_amount
                users[author_id]["losses"] += 1
                formatted_loss = format_currency(bet_amount)
                response=Message(text=f"{user_name} üòû B·∫°n thua! K·∫øt qu·∫£ x√∫c x·∫Øc: {formatted_dice} = {formatted_total}. K·∫øt qu·∫£: {result}. B·∫°n m·∫•t {formatted_loss}.")
            # Send dice images
            # send_dice_images(dice, thread_id, thread_type, client)
            # T·∫°o ·∫£nh g·ªôp t·ª´ ba ·∫£nh x√≠ ng·∫ßu
            combined_image_path = create_dice_image(dice)
            if combined_image_path:
                # G·ª≠i ·∫£nh g·ªôp x√≠ ng·∫ßu
                client.sendLocalImage(
                    imagePath=combined_image_path,
                    message=response,
                    thread_id=thread_id,
                    thread_type=thread_type,
                    width=480*3,
                    height=480
                )
            else:
                print("Kh√¥ng th·ªÉ t·∫°o ·∫£nh g·ªôp.")

            save_users()

        elif command == 'ct':
            if len(query) != 4:
                client.sendMessage(Message(text=f"{user_name} ‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng l·ªánh `-taixiu ct (t√™n ng∆∞·ªùi nh·∫≠n) (s·ªë ti·ªÅn)`."), thread_id, thread_type)
                return

            recipient_name = query[2]
            try:
                transfer_amount = int(query[3])
            except ValueError:
                client.sendMessage(Message(text=f"{user_name} ‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá."), thread_id, thread_type)
                return

            if author_id not in users:
                client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p ƒë·ªÉ chuy·ªÉn ti·ªÅn."), thread_id, thread_type)
                return

            if users[author_id]["balance"] < transfer_amount:
                client.sendMessage(Message(text=f"{user_name} ‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ chuy·ªÉn {format_currency(transfer_amount)}."), thread_id, thread_type)
                return

            recipient_id = next((uid for uid, data in users.items() if data["username"] == recipient_name), None)
            if recipient_id:
                users[author_id]["balance"] -= transfer_amount
                users[recipient_id]["balance"] += transfer_amount
                save_users()
                formatted_transfer_amount = format_currency(transfer_amount)
                client.sendMessage(Message(text=f"{user_name} üí∏ ƒê√£ chuy·ªÉn {formatted_transfer_amount} cho {recipient_name} th√†nh c√¥ng!"), thread_id, thread_type)
                client.sendMessage(Message(text=f"{recipient_name} üí∞ B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c {formatted_transfer_amount} t·ª´ {user_name}."), thread_id, thread_type)
            else:
                client.sendMessage(Message(text=f"{user_name} ‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi nh·∫≠n v·ªõi t√™n {recipient_name}."), thread_id, thread_type)

        elif command == 'code':
            if len(query) != 3:
                client.sendMessage(Message(text=f"{user_name} ‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng l·ªánh `-taixiu code (m√£)`."), thread_id, thread_type)
                return

            code = query[2]
            reward = 0

            if code == "KHAITRUONGNHACAI":
                reward = 5000000000000000
            	

            if reward > 0:
                if author_id not in users:
                    client.sendMessage(Message(text=f"{user_name} ‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p ƒë·ªÉ nh·∫≠n th∆∞·ªüng."), thread_id, thread_type)
                    return

                if code in users[author_id]["used_codes"]:
                    client.sendMessage(Message(text=f"{user_name} ‚ùå B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ n√†y r·ªìi."), thread_id, thread_type)
                    return

                users[author_id]["balance"] += reward
                users[author_id]["used_codes"].add(code)
                formatted_reward = format_currency(reward)
                client.sendMessage(Message(text=f"{user_name} üéÅ Ch√∫c m·ª´ng! B·∫°n ƒë√£ nh·∫≠n {formatted_reward} v·ªõi m√£ {code}."), thread_id, thread_type)
                save_users()
            else:
                client.sendMessage(Message(text=f"{user_name} ‚ùå M√£ kh√¥ng h·ª£p l·ªá."), thread_id, thread_type)
        
        elif command == 'bxh':
            top_users = sorted(users.items(), key=lambda item: item[1]["balance"], reverse=True)[:10]
            if not top_users:
                client.sendMessage(Message(text=f"{user_name} üìâ Hi·ªán t·∫°i kh√¥ng c√≥ d·ªØ li·ªáu b·∫£ng x·∫øp h·∫°ng."), thread_id, thread_type)
                return

            leaderboard = "üèÜ **B·∫£ng X·∫øp H·∫°ng Top 10**\n"
            for rank, (uid, user_info) in enumerate(top_users, start=1):
                formatted_balance = format_currency(user_info["balance"])
                leaderboard += f"{rank}. {user_info['username']} - {formatted_balance}\n"

            client.sendMessage(Message(text=leaderboard), thread_id, thread_type)

    except Exception as e:
        error_message = Message(text=f"ƒê√£ x·∫£y ra l·ªói: {str(e)}")
        client.sendMessage(error_message, thread_id, thread_type)

def fetchGroupName(thread_id):
        
        return "Xb"

def get_mitaizl():
    return {
        'txiu': handle_taixiu_command
    }